# MySQL进阶知识

> 来自：小滴课堂（https://xdclass.net/）

## Mysql事务的四大特性(ACID)

事务的四大特性ACID

- 原子性Atomicity：一个事务必须被事务不可分割的最小工作单元，整个操作要么全部成功，要么全部失败，一般就是通过commit和rollback来控制
- 一致性Consistency: 数据库总能从一个一致性的状态转换到另一个一致性的状态，比如小滴课堂下单支付成功后，开通视频播放权限，只要有任何一方发生异常就不会成功提交事务
- 隔离性Isolation: 一个事务相对于另一个事务是隔离的，一个事务所做的修改是在最终提交以前，对其他事务是不可见的
- 持久性Durability: 一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失

## 脏读-不可重复读-幻读

- 脏读: 事务中的修改即使没有提交，其他事务也能看见，事务可以读到未提交的数据称为脏读。脏读又称无效数据读出（读出了脏数据）。一个事务读取另外一个事务还没有提交的数据叫脏读。

  例如：事务T1修改了某个表中的一行数据，但是还没有提交，这时候事务T2读取了被事务T1修改后的数据，之后事务T1因为某种原因回滚（Rollback）了，那么事务T2读取的数据就是脏的（无效的）。

- 不可重复读: 同个事务前后多次读取，不能读到相同的数据内容，中间另一个事务也操作了该同一数据。不可重复读是指在同一个事务内，两次相同的查询返回了不同的结果。

  例如：事务T1会读取两次数据，在第一次读取某一条数据后，事务T2修改了该数据并提交了事务，T1此时再次读取该数据，两次读取便得到了不同的结果。

- 幻读：当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，发现两次不一样，产生幻读。幻读也是指当事务不独立执行时，插入或者删除另一个事务当前影响的数据而发生的一种类似幻觉的现象。

  例如：系统事务A将数据库中所有数据都删除的时候，但是事务B就在这个时候新插入了一条记录，当事务A删除结束后发现还有一条数据，就好像发生了幻觉一样。这就叫幻读。

幻读和不可重复读的区别是：前者是一个范围，后者是本身，从总的结果来看, 两者都表现为两次读取的结果不一致。

不可重复读出现多是因为修改；幻读重点是新增、删除。mysql中的REPEATABLE_READ模式引入了间隙锁（GAP），解决了幻读的问题。不论是什么方式解决幻读，都会付出一定代价的性能让步。所以说在业务需求和技术方案之间权衡也是技术人员最需要掌握得技能之一。

## 常见的隔离级

事务的隔离级别越高，事务越安全，但是并发能力越差。

- Read Uncommitted(未提交读，读取未提交内容)

  事务中的修改即使没有提交，其他事务也能看见，事务可以读到为提交的数据称为脏读，也存在不可重复读、幻读问题

  例子：
    小滴课堂运营小姐姐配置了一个课程活动，原价500元的课程，配置成50元，但是事务没提交。 
    你刚好看到这个课程那么便宜准备购买，但是Anna小姐姐马上回滚了事务，重新配置并提交了事务，你准备下单的时候发现价格变回了500元

- Read Committed(提交读，读取提交内容)
  一个事务开始后只能看见已经提交的事务所做的修改，在事务中执行两次同样的查询可能得到不一样的结果，也叫做不可重复读(前后多次读取，不能读到相同的数据内容)，也存幻读问题

  例子：
    老王在小滴课堂有1000积分，准备去兑换《面试专题课程》，查询数据库确实有1000积分。但是老王的女友同时也在别的地方登录，把1000积分兑换了《SpringCloud微服务专题课程》，且在老王之前提交事务；当系统帮老王兑换《面试专题课程》是发现积分预计没了，兑换失败。老王事务A事先读取了数据，他女友事务B紧接了更新了数据且提交了事务，事务A再次读取该数据时，数据已经发生了改变。

  

- Repeatable Read(可重复读,mysql默认的事务隔离级别)
  解决脏读、不可重复读的问题，存在幻读的问题，使用 MMVC机制 实现可重复读

  例子：
    老王在小滴课堂有1000积分，准备去兑换《面试专题课程》，查询数据库确实有1000积分
    老王的女友同时也在别的地方登录先兑换了这个《面试专题课程》，老王的事务提交的时候发现存在了，之前读取的没用了，像是幻觉

  幻读问题：MySQL的InnoDB引擎通过MVCC自动帮我们解决,即多版本并发控制

- Serializable(可串行化)
    解决脏读、不可重复读、幻读，可保证事务安全，但强制所有事务串行执行，所以并发效率低

![Image20200827103646](images/Image20200827103646.png)



## Mysql的存储引擎

常见的有多类，InnoDB、MyISAM、MEMORY、MERGE、ARCHIVE、CSV等。一般比较常用的有InnoDB、MyISAM。

MySQL 5.5以上的版本默认是InnoDB，5.5之前默认存储引擎是MyISAM。



|  区别项  |                     Innodb                      |          myisam          |
| :------: | :---------------------------------------------: | :----------------------: |
|   事务   |                      支持                       |          不支持          |
|  锁粒度  |                行锁，适合高并发                 |    表锁，不适合高并发    |
| 是否默认 |                      默认                       |          非默认          |
| 支持外键 |                    支持外键                     |          不支持          |
| 适合场景 |         读写均衡,写大于读场景，需要事务         | 读多写少场景，不需要事务 |
| 全文索引 | 不支持，可以通过插件实现, 更多使用ElasticSearch |       支持全文索引       |



## Mysql数据库索引

| 索引名称 |                             特点                             |                           创建语句                           |
| :------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| 普通索引 |                   最基本的索引,仅加速查询                    |      `CREATE INDEX idx_name ON table_name(filed_name)`       |
| 唯一索引 | 加速查询，列值唯一，允许为空； 组合索引则列值的组合必须唯一  | `CREATE UNIQUE INDEX idx_name ON table_name(filed_name_1,filed_name_2)` |
| 主键索引 |       加速查询，列值唯一， 一个表只有1个，不允许有空值       |   `ALTER TABLE table_name ADD PRIMARY KEY ( filed_name )`    |
| 组合索引 |                   加速查询，多条件组合查询                   | `CREATE INDEX idx_name ON table_name(filed_name_1,filed_name_2);` |
| 覆盖索引 | 索引包含所需要的值，不需要“回表”查询， 比如查询 两个字段，刚好是 组合索引 的两个字段 |                                                              |
| 全文索引 | 对内容进行分词搜索，仅可用于Myisam， 更多用ElasticSearch做搜索 |    `ALTER TABLE table_name ADD FULLTEXT ( filed_name ) `     |

**索引的使用场景和注意事项**

```
中型公司或者业务发展好的公司，一天新增几百万数据量

业务核心数据存储在Mysql里面，针对业务创建合适的索引

打点数据、日志等存储在ElasticSearch或者MongoDB里面
```

- 考虑点：结合实际的业务场景，在哪些字段上创建索引，创建什么类型的索引


- 索引好处：

  ​	快速定位到表的位置，减少服务器扫描的数据

  ​	有些索引存储了实际的值，特定情况下只要使用索引就能完成查询

- 索引缺点：

  ​	索引会浪费磁盘空间，不要创建非必要的索引

  ​	插入、更新、删除需要维护索引，带来额外的开销

  ​	索引过多，修改表的时候重构索引性能差

- 索引优化实践

  ​	前缀索引，特别是TEXT和BLOG类型的字段，只检索前面几个字符，提高检索速度

  ​	尽量使用数据量少的索引，索引值过长查询速度会受到影响

  ​	选择合适的索引列顺序

  ​	内容变动少，且查询频繁，可以建立多几个索引

  ​	内容变动频繁，谨慎创建索引

  ​	根据业务创建适合的索引类型，比如某个字段常用来做查询条件，则为这个字段建立索引提高查询速度

  ​	组合索引选择业务查询最相关的字段





## 参考

https://www.cnblogs.com/vinter/p/12581238.html

https://www.jianshu.com/p/0cef4c68b8f3